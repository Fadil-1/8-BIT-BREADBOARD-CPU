// Defining macros

// Assembly code for NOP. This executes 4 NOPs, each taking approximately 62.5ns, totaling 250ns.
#define NOP __asm__ __volatile__ ("nop\n\t""nop\n\t""nop\n\t""nop\n\t")
NOP; // delay 250ns on a 16MHz AtMega

// Pin definitions
#define data_pin 2
#define clk_pin 3
#define content_register_pin 4

#define EEPROM_D0 5           // Start of EEPROM data pins
#define EEPROM_D7 12          // End of EEPROM data pins

#define WRITE_EN 13           // Write Enable pin for EEPROM

// Default value for padding
const byte DEFAULT_PADDING_VALUE = 0xFF;

void setAddress(int address, bool outputEnable) {
  // Shifting out the high byte of the address with the output enable signal
  shiftOut(data_pin, clk_pin, MSBFIRST, (address >> 8) | (outputEnable ? 0x00 : 0x80));
  // Shifting out the low byte of the address
  shiftOut(data_pin, clk_pin, MSBFIRST, address);

  // Triggering the storage register to latch the data
  digitalWrite(content_register_pin, LOW);
  digitalWrite(content_register_pin, HIGH);
  digitalWrite(content_register_pin, LOW);
}


byte read_byte(int address) {
  // Setting EEPROM data pins as inputs
  for (int pin = EEPROM_D0; pin <= EEPROM_D7; pin += 1) {
    pinMode(pin, INPUT);
  }
  // Setting EEPROM address and output enable to begin the read operation
  setAddress(address, /*outputEnable*/ true);

  // Reading the data byte, bit by bit from the EEPROM
  byte data = 0;
  for (int pin = EEPROM_D7; pin >= EEPROM_D0; pin -= 1) {
    data = (data << 1) + digitalRead(pin); // Assembling the byte from individual bits
  }
  return data;
}


void write_byte(int address, byte data) {
  // Setting address and ensuring output enable is off before the write operation
  setAddress(address, false);
  
  // Configuring EEPROM data pins as outputs
  for (int pin = EEPROM_D0; pin <= EEPROM_D7; pin += 1) {
    pinMode(pin, OUTPUT);
  }

  // Writing the byte to the EEPROM, bit by bit
  for (int pin = EEPROM_D0; pin <= EEPROM_D7; pin += 1) {
    digitalWrite(pin, data & 1); // Writing LSB of the data
    data = data >> 1;           // Shifting data to get the next bit to write
  }
  digitalWrite(WRITE_EN, LOW);  // Enabling write operation
  //NOP;                          // Short delay of 250ns
  delayMicroseconds(1);
  digitalWrite(WRITE_EN, HIGH); // Disabling write operation
  delay(10);
}



void read_ROM(unsigned int address_offset = 0) {
  // Reading and printing EEPROM contents by iterating over each data byte

  Serial.println("Reading EEPROM");
  for (int base = address_offset; base <= (255 + address_offset); base += 16) {
    byte data[16]; // Buffer to hold the data read

    // Reading a block of data
    for (int offset = 0; offset <= 15; offset += 1) {
      data[offset] = read_byte(base + offset);
    }

    // Formatting the data into a string for output
    char buf[80];
    sprintf(buf, "%03x:  %02x %02x %02x %02x %02x %02x %02x %02x   %02x %02x %02x %02x %02x %02x %02x %02x",
            base, data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7],
            data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15]);

    Serial.println(buf); // Sending the formatted data to the serial monitor
  }
}


void erase_ROM(unsigned int address_offset = 0) {
  // EEPROM erase sequence
  Serial.println("Erasing EEPROM");
  for (int address = address_offset; address <= (16383 + address_offset); address += 1) {
    write_byte(address, DEFAULT_PADDING_VALUE); // Writing all bits to DEFAULT_PADDING_VALUE

    if (address == 16383) break;
    // Progress indication
    else if (address % 3200 == 0) {
      Serial.print(address);
      Serial.print(" erased");
      Serial.println(""); 
    }
  }
  Serial.println(" done");

  }



// Array to hold 7-segment display encoding for hexadecimal digits
//byte data[] = { 0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7d, 0x39, 0x5e, 0x79, 0x71 };

/*
// 0_to_65535
byte data[] = {
0x0a, 0x00, 0x03, 0x00, 0xc6, 0xc7, 0x02, 0x0b, 0x01, 0xf4, 0x0f, 0xc0, 0xec, 0x04, 0xc0, 0x02, 
0x04, 0x01, 0xec, 0x04, 0xc0};
*/


/*
// 0_to_65535_to_0
byte data[] = {
0x0a, 0x00, 0x03, 0x00, 0x18, 0x00, 0xc6, 0xc7,    0x01, 0x1e, 0x00, 0xf1, 0x11, 0xc0, 0xec, 0x2e, 
0xc0, 0x02, 0x0b, 0x01, 0xf4, 0x28, 0xc0, 0x01,    0x10, 0xff, 0xf5, 0x06, 0xc0, 0x01, 0x09, 0xff, 
0xf5, 0x06, 0xc0, 0x18, 0x01, 0xec, 0x06, 0xc0,    0x02, 0x04, 0x01, 0xec, 0x06, 0xc0, 0x01, 0x0c, 
0x01, 0xf8, 0x45, 0xc0, 0x01, 0x10, 0x00, 0xf5,    0x06, 0xc0, 0x01, 0x09, 0x00, 0xf5, 0x06, 0xc0, 
0x18, 0x00, 0xec, 0x06, 0xc0, 0x01, 0x05, 0x01,    0xec, 0x06, 0xc0};
*/
/*
// 16-bit Fibonnacci
byte data[] = {
0x03, 0x00, 0x0a, 0x00, 0x11, 0x00, 0x18, 0x01,    0xe4, 0xe6, 0x02, 0x55, 0x27, 0x5c, 0xf4, 0x00, 
0xc0, 0x2c, 0xe3, 0xe1, 0xe0, 0x3f, 0xc5, 0x38,    0xc7, 0xe1, 0xec, 0x08, 0xc0}; 
*/


// OLED
byte data[] = {
0xcd, 0xfe, 0xcf, 0xae, 0xcf, 0x15, 0xcf, 0x00, 0xcf, 0x3f, 0xcf, 0x75, 0xcf, 0x00, 0xcf, 0x3f, 
0xcf, 0x81, 0xcf, 0x7f, 0xcf, 0xa0, 0xcf, 0x52, 0xcf, 0xa1, 0xcf, 0x00, 0xcf, 0xa2, 0xcf, 0x4b, 
0xcf, 0xa4, 0xcf, 0x86, 0xcf, 0xb3, 0xcf, 0xf1, 0xcf, 0xa8, 0xcf, 0x3f, 0xcf, 0xb8, 0xcf, 0x00, 
0xcf, 0x01, 0xcf, 0x02, 0xcf, 0x30, 0xcf, 0x04, 0xcf, 0x50, 0xcf, 0x06, 0xcf, 0x70, 0xcf, 0x24, 
0xcf, 0x00, 0xcf, 0x00, 0xcf, 0x3f, 0xcf, 0x3f, 0xcf, 0x00, 0xcf, 0xaf, 0x2f, 0x00, 0xcf, 0x56, 
0xcf, 0x15, 0xcf, 0x16, 0xcf, 0x34, 0xcf, 0x75, 0xcf, 0x23, 0xcf, 0x31, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xff, 0xce, 0xff, 
0xce, 0xf0, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x0f, 0xce, 0xff, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x0f, 0xce, 0xf0, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0xf0, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0xf0, 0xce, 0x0f, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0x00, 0xce, 0x0f, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0xf0, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 0xce, 0xff, 0xce, 0xff, 
0xce, 0xf0, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x0f, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0xff, 
0xce, 0x00, 0xce, 0x00, 0xce, 0xff, 0xce, 0xff, 0xce, 0xf0, 0xce, 0x00, 0xce, 0x0f, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0xf0, 0xce, 0x00, 0xce, 0x0f, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0xf0, 0xce, 0xf0, 
0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0xf0, 
0xce, 0x00, 0xce, 0x0f, 0xce, 0x00, 0xce, 0x00, 0xce, 0x0f, 0xce, 0xf0, 0xce, 0x00, 0xce, 0x0f, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x0f, 0xce, 0x00, 
0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x0f, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x0f, 0xce, 0xff, 0xce, 0x00, 
0xce, 0x0f, 0xce, 0x00, 0xce, 0x00, 0xce, 0x0f, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xff, 0xce, 0xff, 
0xce, 0xf0, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 0xce, 0xf0, 
0xce, 0x00, 0xce, 0xf0, 0xce, 0xff, 0xce, 0xff, 0xce, 0xf0, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0x2f, 0x07, 0xcf, 0x56, 0xcf, 0x15, 0xcf, 0x16, 0xcf, 0x34, 0xcf, 0x75, 0xcf, 0x23, 0xcf, 0x31, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x0f, 0xce, 0xff, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x0f, 0xce, 0xff, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
0xce, 0xff, 0xce, 0x0f, 0xce, 0xf0, 0xce, 0xf0, 0xce, 0x00, 0xce, 0xf0, 0xce, 0x00, 0xce, 0x00, 
0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 0xce, 0x00, 
};

void write_to_ROM(byte data[], size_t size, unsigned int address_offset =0) {
   
  // EEPROM programming sequence
  Serial.print("Programming EEPROM");
  for (size_t address = address_offset; address < size + address_offset; address++) {
    write_byte(address, data[address - address_offset]); // Writing predefined data to EEPROM

    // Progress indication
    if (address % 100 == 0) {
      Serial.print("."); // Print a dot for every 100 addresses programmed
    }
  }
  Serial.println(" done");
}


void setup() {
  // Setting up the pins for communication with shift registers and EEPROM
  pinMode(data_pin, OUTPUT);
  pinMode(clk_pin, OUTPUT);
  pinMode(content_register_pin, OUTPUT);
  digitalWrite(WRITE_EN, HIGH); // Ensuring EEPROM is not writable on setup
  pinMode(WRITE_EN, OUTPUT);
  
  // Initializing serial communication with the specified baud rate
  Serial.begin(57600); 


  // Find the size of the data array
  size_t dataSize = sizeof(data) / sizeof(data[0]);

  // Write/Read/Erase either first or second half of ROM.
  unsigned int offset = 16383; // Second half

  // Oftentimes read() would only show the true written data after being run twice.
  //erase_ROM(0);
  write_to_ROM(data, dataSize, offset);
  //read_ROM();
  read_ROM(offset);
}

void loop() {
}
